"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PassbaseClient = void 0;
const querystring_1 = require("querystring");
const node_fetch_1 = require("node-fetch");
const configuration_1 = require("./configuration");
const utils_1 = require("./utils");
const Identity_1 = require("./models/Identity");
const ProjectSettings_1 = require("./models/ProjectSettings");
const Resource_1 = require("./models/Resource");
const API_KEY_HEADER = "X-API-KEY";
class PassbaseClient {
    constructor(config) {
        if (!config) {
            throw new utils_1.PassbaseError("missing configuration object");
        }
        if (config.format === configuration_1.ResponseFormats.Xml) {
            throw new utils_1.PassbaseError("XML format not yet available, please use ResponseFormats.Json for now");
        }
        this.config = config;
    }
    async fetchPassbaseAPI(url, method = utils_1.Method.Get, params) {
        var _a, _b;
        if (!url) {
            throw new utils_1.PassbaseError("missing url");
        }
        let body;
        if (method === utils_1.Method.Get) {
            url = url.concat(`?${querystring_1.stringify(params)}`);
        }
        else {
            body = JSON.stringify(params);
        }
        const response = await node_fetch_1.default(`${this.config.basePath}${url}`, {
            method,
            body,
            headers: {
                "User-Agent": configuration_1.SDK_NAME,
                [API_KEY_HEADER]: this.config.apiKey,
                Accept: this.config.format,
            },
        });
        if (!response.ok) {
            const errorText = (await response.text()).trim();
            throw new utils_1.PassbaseError(`Request failed with status=${response.status}${errorText ? `\n${errorText}` : ""}`);
        }
        if (((_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.includes("application/json")) &&
            this.config.format === configuration_1.ResponseFormats.Json) {
            return response.json();
        }
        if (this.config.format === configuration_1.ResponseFormats.Xml && ((_b = response.headers.get("Content-Type")) === null || _b === void 0 ? void 0 : _b.includes("xml"))) {
            return response.text();
        }
        if (response.headers.get("Content-Type")) {
            return response.blob();
        }
        return response.text();
    }
    async getPaginatedData(getter) {
        const results = [];
        let cursor = null;
        let data;
        while (!cursor || cursor.next) {
            ({ cursor, data } = await getter(cursor && cursor.next ? cursor.next : undefined));
            results.push(...data);
        }
        return results;
    }
    /**
     * List authorized identities
     */
    async listIdentities() {
        const identities = await this.getPaginatedData(cursor => this.fetchPassbaseAPI("/identities", utils_1.Method.Get, { cursor }));
        return identities.map(identity => new Identity_1.Identity(identity));
    }
    /**
     * Get identity
     */
    async getIdentityById(identityId) {
        const identity = await this.fetchPassbaseAPI(`/identities/${identityId}`);
        return new Identity_1.Identity(identity);
    }
    /**
     *
     * @deprecated Use {getIdentityById} instead
     */
    async getIdentity(identityId) {
        return this.getIdentityById(identityId);
    }
    /**
     * List identity resources
     */
    async listIdentityResources(identityId) {
        const resources = await this.getPaginatedData(cursor => this.fetchPassbaseAPI(`/identity/${identityId}/resources`, utils_1.Method.Get, {
            cursor,
        }));
        return resources.map(resource => new Resource_1.Resource(resource));
    }
    /**
     * Get resource
     */
    async getIdentityResourceById(identityId, resourceId) {
        const resource = await this.fetchPassbaseAPI(`/identity/${identityId}/resources/${resourceId}`);
        return new Resource_1.Resource(resource);
    }
    /**
     * Get resource
     */
    async getIdentityResourceFileById(identityId, resourceId, resourceFileId) {
        const resourceFile = await this.fetchPassbaseAPI(`/identity/${identityId}/resources/${resourceId}/resource_files/${resourceFileId}`);
        return resourceFile;
    }
    /**
     * Get project settings
     */
    async getSettings() {
        const settings = await this.fetchPassbaseAPI(`/settings`);
        return new ProjectSettings_1.ProjectSettings(settings);
    }
    /**
     *
     * @deprecated Use {getSettings} instead
     */
    async getProjectSettings() {
        return this.getSettings();
    }
}
exports.PassbaseClient = PassbaseClient;
